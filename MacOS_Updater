#!/bin/sh

#
# By Gengik84, rewritten by PMheart
#
# Based on Pike R. Alpha's script and crazybirdy's modifications.
#
# Many thanks to PikeRAlpha, crazybirdy and PMheart!
#

# uncomment to enable debug logging
# set -x

# Change additional shell optional behavior (expand unmatched names to a null string).
shopt -s nullglob

#
# VARIABLES
#
#----------------------------------------------------------------------------------------------------

#
# Beta version (ONLY the latest Beta)
# could be empty when there is no Beta available. (consider 10.14.6)
#
betaVersion="10.14.2"

# stable version (ONLY the latest stable)
stableVersion="10.14.1"

#----------------------------------------------------------------------------------------------------

#
# GLOBAL VARS
# WILL BE UPDATED BY CERTAIN FUNCTIONS
#
#----------------------------------------------------------------------------------------------------

# selected channel for determining URL
# will be updated by selectChannel()
channel=""
# selected catalog URL (see channels and catalogs above)
# will be updated by selectChannel()
catalog=""
# selected system version
version=""
# target destination
volume=""

# package keys
# will be updated by parseCatalog()
urlIndex=""
keyNum=""
keyIndex=""
keySalt=""
# the exact url
url=""
# distribution file
dist=""

# initialisation of a variable (our target folder).
tmpDirectory="/tmp"
workDir=""
# name of target installer package
installerPackage="installer.pkg"
# backup dir
userPath="/Users/`users`/Desktop"

#----------------------------------------------------------------------------------------------------

#
# CONSTANTS
# NO CHANGE NEEDED HERE
#
#----------------------------------------------------------------------------------------------------

# possible channels
channels=(
  # dev beta (pub beta has been dropped)
  "Beta"
  # normal
  "Normal Channel"
)
# possible catalog URLs (corresponding to channels above)
catalogs=(
  # beta
  "https://swscan.apple.com/content/catalogs/others/index-10.14seed-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz"
  # normal
  "https://swscan.apple.com/content/catalogs/others/index-10.14-10.13-10.12-10.11-10.10-10.9-mountainlion-lion-snowleopard-leopard.merged-1.sucatalog.gz"
)

# colors
RED="\e[31m"
GREEN="\e[32m"
DARK_YELLOW="\e[33m"
BLUE="\e[34m"
PURPLE="\e[35m"
CYAN="\e[36m"
OFF="\e[0m"

#----------------------------------------------------------------------------------------------------

function STY_LINE() {
  printf '%s\n\n' '-------------------------------------------------------------------------------'
}

function selectChannel() {
  local i=0
  while true; do
    # list all possible channels
    printf "${CYAN}SELECT A CHANNEL${OFF}\n"
    for c in "${channels[@]}"; do
      printf "[ ${GREEN}${i}${OFF} ] ${PURPLE}${c}${OFF}\n"
      let i++
    done

    local channelNum
    read -p ">> " channelNum
    # insane choice?!
    if [[ -z "${channelNum}" || ! "${channelNum}" =~ ^[0-9]+$ || "${channelNum}" -lt 0 || "${channelNum}" -ge $i ]]; then
      printf "${RED}Wrong choice!${OFF}\n\n"
      # restore i to 0 for another traversal
      i=0
      continue
    fi

    # update vars
    channel="${channels[channelNum]}"
    catalog="${catalogs[channelNum]}"
    # ask for confirmation
    printf "Your choice: [ ${GREEN}${channelNum}${OFF} ] ${PURPLE}${channel}${OFF}\n"
    while true; do
      local confirmChannel
      read -p ">> CONFIRM? (Y/N) " confirmChannel
      case "${confirmChannel}" in
        "" )
          printf 'Please do type Y if you are sure.\n'
          continue
        ;;

        y|Y )
          # done, terminate the function
          return
        ;;

        n|N )
          printf 'goodbye\n'
          exit 0
        ;;

        * )
          printf 'Try again...\n\n'
          # restore i to 0 for another traversal
          i=0
          # go to the last loop
          break
        ;;
      esac
    done
  done
}

function parseCatalog() {
  selectChannel

  # download catalog
  cd "${tmpDirectory}"
  [[ -f update-catalogs ]] && rm -f update-catalogs
  curl "${catalog}" -o update-catalogs.gz && gunzip update-catalogs.gz || exit 1

  # show version
  [[ "${channel}" == "Beta" && ! -z "${betaVersion}" ]] && version="${betaVersion}" || version="${stableVersion}"

  # update vars
  urlIndex="$(cat /tmp/update-catalogs | \
              grep macOSUpd${version} | grep pkg | grep -v RecoveryHDUpdate | grep -v Patch | grep -v integrityData | \
              sed 's/<string>//' | sed 's/<\/string>//' | \
              awk '{print $1;}' | awk NR==1 | sed 's/^.*downloads//')"
  [[ -z "${urlIndex}" ]] && printf "ERROR: ${RED}URL Index not found!${OFF}\n" && exit 1
  keyNum="$(  echo ${urlIndex} | cut -d/ -f2,3)"
  keyIndex="$(echo ${urlIndex} | cut -d/ -f4,4)"
  keySalt="$( echo ${urlIndex} | cut -d/ -f5,5)"
  url="https://swdist.apple.com/content/downloads/${keyNum}/${keyIndex}/${keySalt}/"
  dist="${keyIndex}.English.dist"

  # create our working dir
  workDir="${tmpDirectory}/${keyIndex}"
  [[ ! -d "${workDir}" ]] && mkdir "${workDir}"
  cd "${workDir}"
  # download dist
  rm -f "${dist}"
  printf "Downloading: ${BLUE}${dist}${OFF}...\n"
  curl "${url}${dist}" -o "${dist}"

  # show build
  local awkNR=0
  [[ "${channel}" == "Beta" && ! -z "${betaVersion}" ]] && awkNR=13 || awkNR=12
  build="$(cat ${dist} | \
           sed 's/<string>//' | sed 's/<\/string>//' | \
           awk '{print $1;}'  | awk NR==${awkNR} 2>&1)"

  confirmDownload
}

function confirmDownload() {
  while true; do
    printf "${RED}${version} (${build})${OFF} will be downloaded, confirm? (y/n) "
    local confirmVer
    read -ea confirmVer
    case "${confirmVer}" in
      "" )
        printf 'Please do type Y if you are sure.\n'
        continue
      ;;

      y|Y )
        # done, terminate the function
        return
      ;;

      n|N )
        rm -rf "${workDir}"
        printf 'goodbye\n'
        exit 0
      ;;

      * )
        printf 'Try again...\n\n'
        continue
      ;;
    esac
  done
}

function downloadPackage() {
  # now we are inside "${workDir}" thanks to the prior parseCatalog()

  # packages to be downloaded
  local targetFiles=(
    "FirmwareUpdate.pkg"
    "FullBundleUpdate.pkg"
    "EmbeddedOSFirmware.pkg"
    "macOSUpd${version}.pkg"
    "macOSUpd${version}.Patch.pkg"
    "macOSUpd${version}.RecoveryHDUpdate.pkg"
    "macOSBrain.pkg"
    "SecureBoot.pkg"
  )

  # download them
  for filename in "${targetFiles[@]}"; do
    # just in case there's a previous incomplete download...
    rm -rf "${filename}"
    printf "Downloading: ${BLUE}${filename}${OFF}...\n"
    curl "${url}${filename}" -o "${filename}"

    STY_LINE
  done
}

function selectDestination() {
  cd /Volumes

  local i=0
  local targetVolumes=(*)

  while true; do
    printf "${CYAN}SELECT A DESTINATION${OFF}\n"
    for vol in "${targetVolumes[@]}"; do
      printf "[ ${GREEN}${i}${OFF} ] ${CYAN}${vol}${OFF}\n"
      let i++
    done

    # ask to select a target volume
    local volNum
    read -p ">> " volNum
    # insane choice?!
    if [[ -z "${volNum}" || ! "${volNum}" =~ ^[0-9]+$ || "${volNum}" -lt 0 || "${volNum}" -ge $i ]]; then
      printf "${RED}Wrong choice!${OFF}\n\n"
      # restore i to 0 for another traversal
      i=0
      continue
    fi

    volume="/Volumes/${targetVolumes[volNum]}"
    printf "Your choice: [ ${GREEN}${volNum}${OFF} ] ${CYAN}${vol}${OFF}\n"
    while true; do
      local confirmVol
      read -p ">> CONFIRM? (y/n) " confirmVol
      case "${confirmVol}" in
        "" )
          printf 'Please do type Y if you are sure.\n'
          continue
        ;;

        y|Y )
          # done, terminate the function
          return
        ;;

        * )
          printf 'Try again...\n\n'
          # restore i to 0 for another traversal
          i=0
          # go to the last loop
          break
        ;;
      esac
    done
  done

  # create the enrollment plist
  local seedEnrollmentPlist="${vol}/Users/Shared/.SeedEnrollment.plist"
  # write enrollement plist when missing (seed program options: CustomerSeed, DeveloperSeed)
  if [[ ! -f "${seedEnrollmentPlist}" ]]; then
    echo '<?xml version="1.0" encoding="UTF-8"?>'                                                                  >  "${seedEnrollmentPlist}"
    echo '<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' >> "${seedEnrollmentPlist}"
    echo '<plist version="1.0">'                                                                                   >> "${seedEnrollmentPlist}"
    echo '  <dict>'                                                                                                >> "${seedEnrollmentPlist}"
    echo '    <key>SeedProgram</key>'                                                                              >> "${seedEnrollmentPlist}"
    if [[ "${channel}" == "Beta" ]]; then
      echo '    <string>DeveloperSeed</string>'                                                                    >> "${seedEnrollmentPlist}"
    else
      echo '    <string>CustomerSeed</string>'                                                                     >> "${seedEnrollmentPlist}"
    fi
    echo '  </dict>'                                                                                               >> "${seedEnrollmentPlist}"
    echo '</plist>'                                                                                                >> "${seedEnrollmentPlist}"
  fi
}

function updateRecovery() {
  printf "${CYAN}UPDATING RECOVERY${OFF}\n"

  cd "${tmpDirectory}"
  rm -rf "updRec" && mkdir "updRec" && cd "updRec"

  # download dm for updating Recovery
  curl -O "https://raw.githubusercontent.com/Gengik84/MacOS_Updater/master/dm" && chmod +x dm || exit 1
  local dmBin="${tmpDirectory}/updRec/dm"

  local recPkg="${workDir}/macOSUpd${version}.RecoveryHDUpdate.pkg"
  [[ ! -f "${recPkg}" ]] && printf "ERROR: ${RED}${recPkg} NOT found!${OFF}\n" && exit 1

  local tmpRecUpdDir="/tmp/RecoveryHDUpdate"
  rm -rf "${tmpRecUpdDir}" && pkgutil --expand-full "${recPkg}" "${tmpRecUpdDir}"
  local tmpDmg="${tmpRecUpdDir}/RecoveryHDMeta.dmg"
  # attempt to create a temporary mount point
  local tmpMountPoint="$(/usr/bin/mktemp -d)"
  # mount tmpDmg there
  /usr/bin/hdiutil attach -nobrowse "${tmpDmg}" -mountpoint "${tmpMountPoint}"

  # probe target volume
  local fsType="$(diskutil info "${volume}" | awk '$1 == "Type" { print $NF }')"
  # start updating
  if [[ "${fsType}" == "apfs" ]]; then
    "${dmBin}" ensureRecoveryBooter "${volume}" -base "${tmpMountPoint}/BaseSystem.dmg" "${tmpMountPoint}/BaseSystem.chunklist" -diag "${tmpMountPoint}/AppleDiagnostics.dmg" "${tmpMountPoint}/AppleDiagnostics.chunklist" -diagmachineblacklist 0 -installbootfromtarget 0 -slurpappleboot 0 -delappleboot 0 -addkernelcoredump 0
  else
    "${dmBin}" ensureRecoveryPartition "${volume}" "${tmpMountPoint}/BaseSystem.dmg" "${tmpMountPoint}/BaseSystem.chunklist" "${tmpMountPoint}/AppleDiagnostics.dmg" "${tmpMountPoint}/AppleDiagnostics.chunklist" 0 0 0
  fi

  # done
  /usr/bin/hdiutil eject "${tmpMountPoint}"
  rm -rf "${tmpMountPoint}"
  rm -rf "${tmpRecUpdDir}"
}

function updatePrimarySystem() {
  printf "${CYAN}UPDATING PRIMARY SYSTEM${OFF}\n"

  cd "${workDir}"

  # remove these lines to avoid installer error
  sed -e '/volume-check/d' "${dist}"      > new1.txt
  sed -e '/installation-check/d' new1.txt > new2.txt
  sed -e '/RecoveryHDUpdate/d'   new2.txt > new3.txt
  sed -e '/system-image/d'       new3.txt > new4.txt
  sed -e '/Patch/d'              new4.txt > new5.txt
  cp new5.txt "${dist}"
  rm new?.txt

  # build pkg
  productbuild --distribution "${workDir}/${dist}" --package-path "${workDir}" "${workDir}/${installerPackage}"

  # perform the update by launching the installer
  [[ -f "${workDir}/${installerPackage}" ]] && /usr/sbin/installer -pkg "${workDir}/${installerPackage}" -target "${volume}"
}

function updateSystem() {
  # update Recovery first
  updateRecovery
  # then primary system
  updatePrimarySystem
}

function ask4Backup() {
  local confirmBackup
  read -p "Do you want to backup installer.pkg? (y/N) " confirmBackup
  case "${confirmBackup}" in
    y|Y )
      printf "${CYAN}BACKING UP${OFF}\n"
      hdiutil create -format UDZO -srcfolder "${workDir}/${installerPackage}" "${userPath}/Installer_${version}_${build}"
    ;;
  esac
}

function endProgram() {
  printf "${CYAN}CLEANING UP${OFF}\n"

  rm -rf "${workDir}"
  rm -rf "${tmpDirectory}/update-catalogs"
  rm -rf "${tmpDirectory}/updRec"
  rm -rf "${tmpDirectory}/ver.txt"

  STY_LINE
  printf "${GREEN}RESTART REQUIRED${OFF}\n"
  local confirmReboot
  read -p "Do you want to reboot now? (y/N) " confirmReboot
  case "${confirmReboot}" in
    y|Y )
      reboot
    ;;
  esac

  printf "${RED}ALL DONE${OFF}\nPlease reboot manually.\n"
}

function main() {
  # direct update from a pre-built pkg
  case "$1" in
    -i|--installer )
      selectDestination
      local installerPKG
      read -p "Drag installer.pkg on terminal windows: " installerPKG
      [[ ! -f "${installerPKG}" ]] && echo "${installerPKG} not found!" && exit 1
      printf "${CYAN}UPDATING PRIMARY SYSTEM${OFF}\n"
      /usr/sbin/installer -pkg "${installerPKG}" -target "${volume}"

      endProgram
      # done
      exit 0
    ;;
  esac

  parseCatalog
  downloadPackage

  selectDestination
  updateSystem

  ask4Backup

  endProgram
}

clear

if [[ $EUID -ne 0 ]]; then
  echo "$(basename "$0") must be run as ROOT!"
  sudo "$0" "$@"
else
  main "$@"
fi
